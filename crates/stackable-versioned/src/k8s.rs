use std::collections::HashMap;

use k8s_version::Version;
use schemars::schema::{InstanceType, Schema, SchemaObject, SingleOrVec};

// NOTE (@Techassi): This struct represents a rough first draft of how tracking values across
// CRD versions can be achieved. It is currently untested and unproven and might change down the
// line. Currently, this struct is only generated by the macro but not actually used by any other
// code. The tracking itself will be introduced in a follow-up PR.
#[derive(Clone, Debug, serde::Deserialize, serde::Serialize, schemars::JsonSchema)]
pub struct ChangedValues {
    /// List of values needed when downgrading to a particular version.
    pub downgrades: HashMap<Version, Vec<ChangedValue>>,

    /// List of values needed when upgrading to a particular version.
    pub upgrades: HashMap<Version, Vec<ChangedValue>>,
}

#[derive(Clone, Debug, serde::Deserialize, serde::Serialize, schemars::JsonSchema)]
pub struct ChangedValue {
    /// The name of the field of the custom resource this value is for.
    pub name: String,

    /// The value to be used when upgrading or downgrading the custom resource.
    #[schemars(schema_with = "raw_object_schema")]
    pub value: serde_yaml::Value,
}

// TODO (@Techassi): Think about where this should live. Basically this already exists in
// stackable-operator, but we cannot use it without depending on it which I would like to
// avoid.
fn raw_object_schema(_: &mut schemars::r#gen::SchemaGenerator) -> Schema {
    Schema::Object(SchemaObject {
        instance_type: Some(SingleOrVec::Single(Box::new(InstanceType::Object))),
        extensions: [(
            "x-kubernetes-preserve-unknown-fields".to_owned(),
            serde_json::Value::Bool(true),
        )]
        .into(),
        ..Default::default()
    })
}
