use std::collections::HashMap;

use k8s_version::Version;
use schemars::schema::{InstanceType, Schema, SchemaObject, SingleOrVec};
use snafu::{ErrorCompat, Snafu};

// NOTE (@Techassi): This struct represents a rough first draft of how tracking values across
// CRD versions can be achieved. It is currently untested and unproven and might change down the
// line. Currently, this struct is only generated by the macro but not actually used by any other
// code. The tracking itself will be introduced in a follow-up PR.
/// Contains changed values during upgrades and downgrades of CRDs.
#[derive(Clone, Debug, serde::Deserialize, serde::Serialize, schemars::JsonSchema)]
pub struct ChangedValues {
    /// List of values needed when downgrading to a particular version.
    pub downgrades: HashMap<Version, Vec<ChangedValue>>,

    /// List of values needed when upgrading to a particular version.
    pub upgrades: HashMap<Version, Vec<ChangedValue>>,
}

/// Contains a changed value for a single field of the CRD.
#[derive(Clone, Debug, serde::Deserialize, serde::Serialize, schemars::JsonSchema)]
pub struct ChangedValue {
    /// The name of the field of the custom resource this value is for.
    pub name: String,

    /// The value to be used when upgrading or downgrading the custom resource.
    #[schemars(schema_with = "raw_object_schema")]
    pub value: serde_yaml::Value,
}

// TODO (@Techassi): Think about where this should live. Basically this already exists in
// stackable-operator, but we cannot use it without depending on it which I would like to
// avoid.
fn raw_object_schema(_: &mut schemars::r#gen::SchemaGenerator) -> Schema {
    Schema::Object(SchemaObject {
        instance_type: Some(SingleOrVec::Single(Box::new(InstanceType::Object))),
        extensions: [(
            "x-kubernetes-preserve-unknown-fields".to_owned(),
            serde_json::Value::Bool(true),
        )]
        .into(),
        ..Default::default()
    })
}

/// This error indicates that parsing an object from a conversion review failed.
#[derive(Debug, Snafu)]
pub enum ParseObjectError {
    #[snafu(display(r#"failed to find "apiVersion" field"#))]
    FieldNotPresent,

    #[snafu(display(r#"the "apiVersion" field must be a string"#))]
    FieldNotStr,

    #[snafu(display("encountered unknown object api version {api_version:?}"))]
    UnknownApiVersion { api_version: String },

    #[snafu(display("failed to deserialize object from JSON"))]
    Deserialize { source: serde_json::Error },
}

/// This error indicates that converting an object from a conversion review to the desired
/// version failed.
#[derive(Debug, Snafu)]
pub enum ConvertObjectError {
    #[snafu(display("failed to parse object"))]
    Parse { source: ParseObjectError },

    #[snafu(display("failed to serialize object into json"))]
    Serialize { source: serde_json::Error },
}

impl ConvertObjectError {
    /// Joins the error and its sources using colons.
    pub fn join_errors(&self) -> String {
        // NOTE (@Techassi): This can be done with itertools in a way shorter
        // fashion but obviously brings in another dependency. Which of those
        // two solutions performs better needs to evaluated.
        // self.iter_chain().join(": ")
        self.iter_chain()
            .map(|err| err.to_string())
            .collect::<Vec<String>>()
            .join(": ")
    }

    /// Returns a HTTP status code based on the underlying error.
    pub fn http_status_code(&self) -> u16 {
        match self {
            ConvertObjectError::Parse { .. } => 400,
            ConvertObjectError::Serialize { .. } => 500,
        }
    }
}
