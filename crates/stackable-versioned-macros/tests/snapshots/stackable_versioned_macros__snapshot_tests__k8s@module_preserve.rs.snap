---
source: crates/stackable-versioned-macros/src/lib.rs
expression: formatted
input_file: crates/stackable-versioned-macros/tests/inputs/k8s/pass/module_preserve.rs
---
#[automatically_derived]
pub(crate) mod versioned {
    pub mod v1alpha1 {
        use super::*;
        pub struct Baz {
            pub boom: Option<u16>,
        }
        #[derive(
            Clone,
            Debug,
            serde::Deserialize,
            serde::Serialize,
            schemars::JsonSchema,
            kube::CustomResource,
        )]
        #[kube(
            group = "foo.example.org",
            version = "v1alpha1",
            kind = "Foo",
            plural = "foos",
            namespaced
        )]
        pub struct FooSpec {
            pub bar: usize,
            pub foo: String,
        }
        #[derive(
            Clone,
            Debug,
            serde::Deserialize,
            serde::Serialize,
            schemars::JsonSchema,
            kube::CustomResource,
        )]
        #[kube(
            group = "bar.example.org",
            version = "v1alpha1",
            kind = "Bar",
            plural = "bars"
        )]
        pub struct BarSpec {
            pub baz: String,
        }
        pub enum Boom {
            Big,
            Shaq,
        }
    }
    impl ::std::convert::From<v1alpha1::Baz> for v1::Baz {
        fn from(__sv_baz: v1alpha1::Baz) -> Self {
            Self { boom: __sv_baz.boom.into() }
        }
    }
    impl ::std::convert::From<v1::Baz> for v1alpha1::Baz {
        fn from(__sv_baz: v1::Baz) -> Self {
            Self { boom: __sv_baz.boom.into() }
        }
    }
    impl ::std::convert::From<v1alpha1::FooSpec> for v1::FooSpec {
        fn from(__sv_foospec: v1alpha1::FooSpec) -> Self {
            Self {
                bar: __sv_foospec.bar.into(),
                baz: ::std::default::Default::default(),
                foo: __sv_foospec.foo.into(),
            }
        }
    }
    impl ::std::convert::From<v1::FooSpec> for v1alpha1::FooSpec {
        fn from(__sv_foospec: v1::FooSpec) -> Self {
            Self {
                bar: __sv_foospec.bar.into(),
                foo: __sv_foospec.foo.into(),
            }
        }
    }
    impl ::std::convert::From<v1alpha1::BarSpec> for v1::BarSpec {
        fn from(__sv_barspec: v1alpha1::BarSpec) -> Self {
            Self {
                baz: __sv_barspec.baz.into(),
            }
        }
    }
    impl ::std::convert::From<v1::BarSpec> for v1alpha1::BarSpec {
        fn from(__sv_barspec: v1::BarSpec) -> Self {
            Self {
                baz: __sv_barspec.baz.into(),
            }
        }
    }
    impl ::std::convert::From<v1alpha1::Boom> for v1::Boom {
        fn from(__sv_boom: v1alpha1::Boom) -> Self {
            match __sv_boom {
                v1alpha1::Boom::Big => v1::Boom::Big,
                v1alpha1::Boom::Shaq => v1::Boom::Shaq,
            }
        }
    }
    impl ::std::convert::From<v1::Boom> for v1alpha1::Boom {
        fn from(__sv_boom: v1::Boom) -> Self {
            match __sv_boom {
                v1::Boom::Big => v1alpha1::Boom::Big,
                v1::Boom::Shaq => v1alpha1::Boom::Shaq,
            }
        }
    }
    pub mod v1 {
        use super::*;
        pub struct Baz {
            pub boom: Option<u16>,
        }
        #[derive(
            Clone,
            Debug,
            serde::Deserialize,
            serde::Serialize,
            schemars::JsonSchema,
            kube::CustomResource,
        )]
        #[kube(
            group = "foo.example.org",
            version = "v1",
            kind = "Foo",
            plural = "foos",
            namespaced
        )]
        pub struct FooSpec {
            pub bar: usize,
            pub baz: bool,
            pub foo: String,
        }
        #[derive(
            Clone,
            Debug,
            serde::Deserialize,
            serde::Serialize,
            schemars::JsonSchema,
            kube::CustomResource,
        )]
        #[kube(group = "bar.example.org", version = "v1", kind = "Bar", plural = "bars")]
        pub struct BarSpec {
            pub baz: String,
        }
        pub enum Boom {
            Big,
            Shaq,
        }
    }
    impl ::std::convert::From<v1::Baz> for v2alpha1::Baz {
        fn from(__sv_baz: v1::Baz) -> Self {
            Self { boom: __sv_baz.boom.into() }
        }
    }
    impl ::std::convert::From<v2alpha1::Baz> for v1::Baz {
        fn from(__sv_baz: v2alpha1::Baz) -> Self {
            Self { boom: __sv_baz.boom.into() }
        }
    }
    #[allow(deprecated)]
    impl ::std::convert::From<v1::FooSpec> for v2alpha1::FooSpec {
        fn from(__sv_foospec: v1::FooSpec) -> Self {
            Self {
                bar: __sv_foospec.bar.into(),
                baz: __sv_foospec.baz.into(),
                deprecated_foo: __sv_foospec.foo.into(),
            }
        }
    }
    #[allow(deprecated)]
    impl ::std::convert::From<v2alpha1::FooSpec> for v1::FooSpec {
        fn from(__sv_foospec: v2alpha1::FooSpec) -> Self {
            Self {
                bar: __sv_foospec.bar.into(),
                baz: __sv_foospec.baz.into(),
                foo: __sv_foospec.deprecated_foo.into(),
            }
        }
    }
    impl ::std::convert::From<v1::BarSpec> for v2alpha1::BarSpec {
        fn from(__sv_barspec: v1::BarSpec) -> Self {
            Self {
                baz: __sv_barspec.baz.into(),
            }
        }
    }
    impl ::std::convert::From<v2alpha1::BarSpec> for v1::BarSpec {
        fn from(__sv_barspec: v2alpha1::BarSpec) -> Self {
            Self {
                baz: __sv_barspec.baz.into(),
            }
        }
    }
    impl ::std::convert::From<v1::Boom> for v2alpha1::Boom {
        fn from(__sv_boom: v1::Boom) -> Self {
            match __sv_boom {
                v1::Boom::Big => v2alpha1::Boom::Big,
                v1::Boom::Shaq => v2alpha1::Boom::Shaq,
            }
        }
    }
    impl ::std::convert::From<v2alpha1::Boom> for v1::Boom {
        fn from(__sv_boom: v2alpha1::Boom) -> Self {
            match __sv_boom {
                v2alpha1::Boom::Big => v1::Boom::Big,
                v2alpha1::Boom::Shaq => v1::Boom::Shaq,
            }
        }
    }
    pub mod v2alpha1 {
        use super::*;
        pub struct Baz {
            pub boom: Option<u16>,
        }
        #[derive(
            Clone,
            Debug,
            serde::Deserialize,
            serde::Serialize,
            schemars::JsonSchema,
            kube::CustomResource,
        )]
        #[kube(
            group = "foo.example.org",
            version = "v2alpha1",
            kind = "Foo",
            plural = "foos",
            namespaced
        )]
        pub struct FooSpec {
            pub bar: usize,
            pub baz: bool,
            #[deprecated]
            pub deprecated_foo: String,
        }
        #[derive(
            Clone,
            Debug,
            serde::Deserialize,
            serde::Serialize,
            schemars::JsonSchema,
            kube::CustomResource,
        )]
        #[kube(
            group = "bar.example.org",
            version = "v2alpha1",
            kind = "Bar",
            plural = "bars"
        )]
        pub struct BarSpec {
            pub baz: String,
        }
        pub enum Boom {
            Big,
            Shaq,
        }
    }
    pub enum Foo {
        V1Alpha1,
        V1,
        V2Alpha1,
    }
    impl ::std::fmt::Display for Foo {
        fn fmt(
            &self,
            f: &mut ::std::fmt::Formatter<'_>,
        ) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::V1Alpha1 => f.write_str("v1alpha1"),
                Self::V1 => f.write_str("v1"),
                Self::V2Alpha1 => f.write_str("v2alpha1"),
            }
        }
    }
    impl Foo {
        /// Generates a merged CRD containing all versions and marking `stored_apiversion` as stored.
        pub fn merged_crd(
            stored_apiversion: Self,
        ) -> ::std::result::Result<
            ::k8s_openapi::apiextensions_apiserver::pkg::apis::apiextensions::v1::CustomResourceDefinition,
            ::kube::core::crd::MergeError,
        > {
            ::kube::core::crd::merge_crds(
                vec![
                    < v1alpha1::Foo as ::kube::core::CustomResourceExt > ::crd(), <
                    v1::Foo as ::kube::core::CustomResourceExt > ::crd(), < v2alpha1::Foo
                    as ::kube::core::CustomResourceExt > ::crd()
                ],
                &stored_apiversion.to_string(),
            )
        }
    }
    /// Parses the version, such as `v1alpha1`
    impl ::std::str::FromStr for Foo {
        type Err = ::stackable_versioned::ParseResourceVersionError;
        fn from_str(version: &str) -> Result<Self, Self::Err> {
            match version {
                "v1alpha1" => Ok(Self::V1Alpha1),
                "v1" => Ok(Self::V1),
                "v2alpha1" => Ok(Self::V2Alpha1),
                _ => {
                    Err(::stackable_versioned::ParseResourceVersionError::UnknownResourceVersion {
                        version: version.to_string(),
                    })
                }
            }
        }
    }
    /// Parses the entire `apiVersion`, such as `zookeeper.stackable.tech/v1alpha1`.
    impl Foo {
        pub fn from_api_version(
            api_version: &str,
        ) -> Result<Self, ::stackable_versioned::ParseResourceVersionError> {
            match api_version {
                "foo.example.org/v1alpha1" => Ok(Self::V1Alpha1),
                "foo.example.org/v1" => Ok(Self::V1),
                "foo.example.org/v2alpha1" => Ok(Self::V2Alpha1),
                _ => {
                    Err(::stackable_versioned::ParseResourceVersionError::UnknownApiVersion {
                        api_version: api_version.to_string(),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl Foo {
        #[tracing::instrument(
            skip_all,
            fields(
                conversion.kind = review.types.kind,
                conversion.api_version = review.types.api_version,
            )
        )]
        pub fn convert(
            review: ::kube::core::conversion::ConversionReview,
        ) -> ::kube::core::conversion::ConversionReview {
            use ::kube::core::conversion::{ConversionRequest, ConversionResponse};
            use ::kube::core::response::StatusSummary;
            use ::stackable_versioned::ConversionError;
            let request = match ConversionRequest::from_review(review) {
                Ok(request) => request,
                Err(err) => {
                    tracing::warn!(
                        ? err,
                        "Invalid ConversionReview send by Kubernetes apiserver. It probably did not include a request"
                    );
                    return ConversionResponse::invalid(::kube::client::Status {
                            status: Some(StatusSummary::Failure),
                            code: 400,
                            message: format!(
                                "The ConversionReview send did not include any request: {err}"
                            ),
                            reason: "ConversionReview request missing".to_string(),
                            details: None,
                        })
                        .into_review();
                }
            };
            let converted = Self::try_convert(&request);
            let conversion_response = ConversionResponse::for_request(request);
            match converted {
                Ok(converted) => {
                    tracing::debug!(
                        "Successfully converted {num} objects of type {type}", num =
                        converted.len(), type = stringify!(Foo),
                    );
                    conversion_response.success(converted).into_review()
                }
                Err(err) => {
                    let error_message = err.as_human_readable_error_message();
                    conversion_response
                        .failure(::kube::client::Status {
                            status: Some(StatusSummary::Failure),
                            code: err.http_return_code(),
                            message: error_message.clone(),
                            reason: error_message,
                            details: None,
                        })
                        .into_review()
                }
            }
        }
        #[tracing::instrument(skip_all, err)]
        fn try_convert(
            request: &::kube::core::conversion::ConversionRequest,
        ) -> Result<Vec<serde_json::Value>, ::stackable_versioned::ConversionError> {
            use ::stackable_versioned::ConversionError;
            let desired_object_version = Self::from_api_version(
                    &request.desired_api_version,
                )
                .map_err(|err| ConversionError::ParseDesiredResourceVersion {
                    source: err,
                    version: request.desired_api_version.to_string(),
                })?;
            let mut converted: Vec<serde_json::Value> = Vec::with_capacity(
                request.objects.len(),
            );
            for object in &request.objects {
                let object_spec = object
                    .get("spec")
                    .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                    })?;
                let object_kind = object
                    .get("kind")
                    .ok_or_else(|| ConversionError::ObjectHasNoKind {
                    })?;
                let object_kind = object_kind
                    .as_str()
                    .ok_or_else(|| ConversionError::ObjectKindNotString {
                        kind: object_kind.clone(),
                    })?;
                let object_version = object
                    .get("apiVersion")
                    .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                    })?;
                let object_version = object_version
                    .as_str()
                    .ok_or_else(|| ConversionError::ObjectApiVersionNotString {
                        api_version: object_version.clone(),
                    })?;
                if object_kind != stringify!(Foo) {
                    return Err(ConversionError::WrongObjectKind {
                        expected_kind: stringify!(Foo).to_string(),
                        send_kind: object_kind.to_string(),
                    });
                }
                let current_object_version = Self::from_api_version(object_version)
                    .map_err(|err| ConversionError::ParseCurrentResourceVersion {
                        source: err,
                        version: object_version.to_string(),
                    })?;
                match (&current_object_version, &desired_object_version) {
                    (Self::V1Alpha1, Self::V1Alpha1) => {
                        let resource_spec: v1alpha1::FooSpec = serde_json::from_value(
                                object_spec.clone(),
                            )
                            .map_err(|err| ConversionError::DeserializeObjectSpec {
                                source: err,
                                kind: stringify!(Foo).to_string(),
                            })?;
                        tracing::trace!(
                            from = stringify!(v1alpha1), to = stringify!("v1alpha1"),
                            conversion.steps = 0usize,
                            "Successfully converted {type} object", type =
                            stringify!(Foo),
                        );
                        let mut object = object.clone();
                        *object
                            .get_mut("spec")
                            .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                            })? = serde_json::to_value(resource_spec)
                            .map_err(|err| ConversionError::SerializeObjectSpec {
                                source: err,
                                kind: stringify!(Foo).to_string(),
                            })?;
                        *object
                            .get_mut("apiVersion")
                            .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                            })? = serde_json::Value::String(
                            request.desired_api_version.clone(),
                        );
                        converted.push(object);
                    }
                    (Self::V1Alpha1, Self::V1) => {
                        let resource_spec: v1alpha1::FooSpec = serde_json::from_value(
                                object_spec.clone(),
                            )
                            .map_err(|err| ConversionError::DeserializeObjectSpec {
                                source: err,
                                kind: stringify!(Foo).to_string(),
                            })?;
                        let resource_spec: v1::FooSpec = resource_spec.into();
                        tracing::trace!(
                            from = stringify!(v1alpha1), to = stringify!("v1"),
                            conversion.steps = 1usize,
                            "Successfully converted {type} object", type =
                            stringify!(Foo),
                        );
                        let mut object = object.clone();
                        *object
                            .get_mut("spec")
                            .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                            })? = serde_json::to_value(resource_spec)
                            .map_err(|err| ConversionError::SerializeObjectSpec {
                                source: err,
                                kind: stringify!(Foo).to_string(),
                            })?;
                        *object
                            .get_mut("apiVersion")
                            .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                            })? = serde_json::Value::String(
                            request.desired_api_version.clone(),
                        );
                        converted.push(object);
                    }
                    (Self::V1Alpha1, Self::V2Alpha1) => {
                        let resource_spec: v1alpha1::FooSpec = serde_json::from_value(
                                object_spec.clone(),
                            )
                            .map_err(|err| ConversionError::DeserializeObjectSpec {
                                source: err,
                                kind: stringify!(Foo).to_string(),
                            })?;
                        let resource_spec: v1::FooSpec = resource_spec.into();
                        let resource_spec: v2alpha1::FooSpec = resource_spec.into();
                        tracing::trace!(
                            from = stringify!(v1alpha1), to = stringify!("v2alpha1"),
                            conversion.steps = 2usize,
                            "Successfully converted {type} object", type =
                            stringify!(Foo),
                        );
                        let mut object = object.clone();
                        *object
                            .get_mut("spec")
                            .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                            })? = serde_json::to_value(resource_spec)
                            .map_err(|err| ConversionError::SerializeObjectSpec {
                                source: err,
                                kind: stringify!(Foo).to_string(),
                            })?;
                        *object
                            .get_mut("apiVersion")
                            .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                            })? = serde_json::Value::String(
                            request.desired_api_version.clone(),
                        );
                        converted.push(object);
                    }
                    (Self::V1, Self::V1Alpha1) => {
                        let resource_spec: v1::FooSpec = serde_json::from_value(
                                object_spec.clone(),
                            )
                            .map_err(|err| ConversionError::DeserializeObjectSpec {
                                source: err,
                                kind: stringify!(Foo).to_string(),
                            })?;
                        let resource_spec: v1alpha1::FooSpec = resource_spec.into();
                        tracing::trace!(
                            from = stringify!(v1), to = stringify!("v1alpha1"),
                            conversion.steps = 1usize,
                            "Successfully converted {type} object", type =
                            stringify!(Foo),
                        );
                        let mut object = object.clone();
                        *object
                            .get_mut("spec")
                            .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                            })? = serde_json::to_value(resource_spec)
                            .map_err(|err| ConversionError::SerializeObjectSpec {
                                source: err,
                                kind: stringify!(Foo).to_string(),
                            })?;
                        *object
                            .get_mut("apiVersion")
                            .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                            })? = serde_json::Value::String(
                            request.desired_api_version.clone(),
                        );
                        converted.push(object);
                    }
                    (Self::V1, Self::V1) => {
                        let resource_spec: v1::FooSpec = serde_json::from_value(
                                object_spec.clone(),
                            )
                            .map_err(|err| ConversionError::DeserializeObjectSpec {
                                source: err,
                                kind: stringify!(Foo).to_string(),
                            })?;
                        tracing::trace!(
                            from = stringify!(v1), to = stringify!("v1"), conversion
                            .steps = 0usize, "Successfully converted {type} object", type
                            = stringify!(Foo),
                        );
                        let mut object = object.clone();
                        *object
                            .get_mut("spec")
                            .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                            })? = serde_json::to_value(resource_spec)
                            .map_err(|err| ConversionError::SerializeObjectSpec {
                                source: err,
                                kind: stringify!(Foo).to_string(),
                            })?;
                        *object
                            .get_mut("apiVersion")
                            .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                            })? = serde_json::Value::String(
                            request.desired_api_version.clone(),
                        );
                        converted.push(object);
                    }
                    (Self::V1, Self::V2Alpha1) => {
                        let resource_spec: v1::FooSpec = serde_json::from_value(
                                object_spec.clone(),
                            )
                            .map_err(|err| ConversionError::DeserializeObjectSpec {
                                source: err,
                                kind: stringify!(Foo).to_string(),
                            })?;
                        let resource_spec: v2alpha1::FooSpec = resource_spec.into();
                        tracing::trace!(
                            from = stringify!(v1), to = stringify!("v2alpha1"),
                            conversion.steps = 1usize,
                            "Successfully converted {type} object", type =
                            stringify!(Foo),
                        );
                        let mut object = object.clone();
                        *object
                            .get_mut("spec")
                            .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                            })? = serde_json::to_value(resource_spec)
                            .map_err(|err| ConversionError::SerializeObjectSpec {
                                source: err,
                                kind: stringify!(Foo).to_string(),
                            })?;
                        *object
                            .get_mut("apiVersion")
                            .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                            })? = serde_json::Value::String(
                            request.desired_api_version.clone(),
                        );
                        converted.push(object);
                    }
                    (Self::V2Alpha1, Self::V1Alpha1) => {
                        let resource_spec: v2alpha1::FooSpec = serde_json::from_value(
                                object_spec.clone(),
                            )
                            .map_err(|err| ConversionError::DeserializeObjectSpec {
                                source: err,
                                kind: stringify!(Foo).to_string(),
                            })?;
                        let resource_spec: v1::FooSpec = resource_spec.into();
                        let resource_spec: v1alpha1::FooSpec = resource_spec.into();
                        tracing::trace!(
                            from = stringify!(v2alpha1), to = stringify!("v1alpha1"),
                            conversion.steps = 2usize,
                            "Successfully converted {type} object", type =
                            stringify!(Foo),
                        );
                        let mut object = object.clone();
                        *object
                            .get_mut("spec")
                            .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                            })? = serde_json::to_value(resource_spec)
                            .map_err(|err| ConversionError::SerializeObjectSpec {
                                source: err,
                                kind: stringify!(Foo).to_string(),
                            })?;
                        *object
                            .get_mut("apiVersion")
                            .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                            })? = serde_json::Value::String(
                            request.desired_api_version.clone(),
                        );
                        converted.push(object);
                    }
                    (Self::V2Alpha1, Self::V1) => {
                        let resource_spec: v2alpha1::FooSpec = serde_json::from_value(
                                object_spec.clone(),
                            )
                            .map_err(|err| ConversionError::DeserializeObjectSpec {
                                source: err,
                                kind: stringify!(Foo).to_string(),
                            })?;
                        let resource_spec: v1::FooSpec = resource_spec.into();
                        tracing::trace!(
                            from = stringify!(v2alpha1), to = stringify!("v1"),
                            conversion.steps = 1usize,
                            "Successfully converted {type} object", type =
                            stringify!(Foo),
                        );
                        let mut object = object.clone();
                        *object
                            .get_mut("spec")
                            .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                            })? = serde_json::to_value(resource_spec)
                            .map_err(|err| ConversionError::SerializeObjectSpec {
                                source: err,
                                kind: stringify!(Foo).to_string(),
                            })?;
                        *object
                            .get_mut("apiVersion")
                            .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                            })? = serde_json::Value::String(
                            request.desired_api_version.clone(),
                        );
                        converted.push(object);
                    }
                    (Self::V2Alpha1, Self::V2Alpha1) => {
                        let resource_spec: v2alpha1::FooSpec = serde_json::from_value(
                                object_spec.clone(),
                            )
                            .map_err(|err| ConversionError::DeserializeObjectSpec {
                                source: err,
                                kind: stringify!(Foo).to_string(),
                            })?;
                        tracing::trace!(
                            from = stringify!(v2alpha1), to = stringify!("v2alpha1"),
                            conversion.steps = 0usize,
                            "Successfully converted {type} object", type =
                            stringify!(Foo),
                        );
                        let mut object = object.clone();
                        *object
                            .get_mut("spec")
                            .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                            })? = serde_json::to_value(resource_spec)
                            .map_err(|err| ConversionError::SerializeObjectSpec {
                                source: err,
                                kind: stringify!(Foo).to_string(),
                            })?;
                        *object
                            .get_mut("apiVersion")
                            .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                            })? = serde_json::Value::String(
                            request.desired_api_version.clone(),
                        );
                        converted.push(object);
                    }
                }
            }
            Ok(converted)
        }
    }
    pub enum Bar {
        V1Alpha1,
        V1,
        V2Alpha1,
    }
    impl ::std::fmt::Display for Bar {
        fn fmt(
            &self,
            f: &mut ::std::fmt::Formatter<'_>,
        ) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::V1Alpha1 => f.write_str("v1alpha1"),
                Self::V1 => f.write_str("v1"),
                Self::V2Alpha1 => f.write_str("v2alpha1"),
            }
        }
    }
    impl Bar {
        /// Generates a merged CRD containing all versions and marking `stored_apiversion` as stored.
        pub fn merged_crd(
            stored_apiversion: Self,
        ) -> ::std::result::Result<
            ::k8s_openapi::apiextensions_apiserver::pkg::apis::apiextensions::v1::CustomResourceDefinition,
            ::kube::core::crd::MergeError,
        > {
            ::kube::core::crd::merge_crds(
                vec![
                    < v1alpha1::Bar as ::kube::core::CustomResourceExt > ::crd(), <
                    v1::Bar as ::kube::core::CustomResourceExt > ::crd(), < v2alpha1::Bar
                    as ::kube::core::CustomResourceExt > ::crd()
                ],
                &stored_apiversion.to_string(),
            )
        }
    }
    /// Parses the version, such as `v1alpha1`
    impl ::std::str::FromStr for Bar {
        type Err = ::stackable_versioned::ParseResourceVersionError;
        fn from_str(version: &str) -> Result<Self, Self::Err> {
            match version {
                "v1alpha1" => Ok(Self::V1Alpha1),
                "v1" => Ok(Self::V1),
                "v2alpha1" => Ok(Self::V2Alpha1),
                _ => {
                    Err(::stackable_versioned::ParseResourceVersionError::UnknownResourceVersion {
                        version: version.to_string(),
                    })
                }
            }
        }
    }
    /// Parses the entire `apiVersion`, such as `zookeeper.stackable.tech/v1alpha1`.
    impl Bar {
        pub fn from_api_version(
            api_version: &str,
        ) -> Result<Self, ::stackable_versioned::ParseResourceVersionError> {
            match api_version {
                "bar.example.org/v1alpha1" => Ok(Self::V1Alpha1),
                "bar.example.org/v1" => Ok(Self::V1),
                "bar.example.org/v2alpha1" => Ok(Self::V2Alpha1),
                _ => {
                    Err(::stackable_versioned::ParseResourceVersionError::UnknownApiVersion {
                        api_version: api_version.to_string(),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl Bar {
        #[tracing::instrument(
            skip_all,
            fields(
                conversion.kind = review.types.kind,
                conversion.api_version = review.types.api_version,
            )
        )]
        pub fn convert(
            review: ::kube::core::conversion::ConversionReview,
        ) -> ::kube::core::conversion::ConversionReview {
            use ::kube::core::conversion::{ConversionRequest, ConversionResponse};
            use ::kube::core::response::StatusSummary;
            use ::stackable_versioned::ConversionError;
            let request = match ConversionRequest::from_review(review) {
                Ok(request) => request,
                Err(err) => {
                    tracing::warn!(
                        ? err,
                        "Invalid ConversionReview send by Kubernetes apiserver. It probably did not include a request"
                    );
                    return ConversionResponse::invalid(::kube::client::Status {
                            status: Some(StatusSummary::Failure),
                            code: 400,
                            message: format!(
                                "The ConversionReview send did not include any request: {err}"
                            ),
                            reason: "ConversionReview request missing".to_string(),
                            details: None,
                        })
                        .into_review();
                }
            };
            let converted = Self::try_convert(&request);
            let conversion_response = ConversionResponse::for_request(request);
            match converted {
                Ok(converted) => {
                    tracing::debug!(
                        "Successfully converted {num} objects of type {type}", num =
                        converted.len(), type = stringify!(Bar),
                    );
                    conversion_response.success(converted).into_review()
                }
                Err(err) => {
                    let error_message = err.as_human_readable_error_message();
                    conversion_response
                        .failure(::kube::client::Status {
                            status: Some(StatusSummary::Failure),
                            code: err.http_return_code(),
                            message: error_message.clone(),
                            reason: error_message,
                            details: None,
                        })
                        .into_review()
                }
            }
        }
        #[tracing::instrument(skip_all, err)]
        fn try_convert(
            request: &::kube::core::conversion::ConversionRequest,
        ) -> Result<Vec<serde_json::Value>, ::stackable_versioned::ConversionError> {
            use ::stackable_versioned::ConversionError;
            let desired_object_version = Self::from_api_version(
                    &request.desired_api_version,
                )
                .map_err(|err| ConversionError::ParseDesiredResourceVersion {
                    source: err,
                    version: request.desired_api_version.to_string(),
                })?;
            let mut converted: Vec<serde_json::Value> = Vec::with_capacity(
                request.objects.len(),
            );
            for object in &request.objects {
                let object_spec = object
                    .get("spec")
                    .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                    })?;
                let object_kind = object
                    .get("kind")
                    .ok_or_else(|| ConversionError::ObjectHasNoKind {
                    })?;
                let object_kind = object_kind
                    .as_str()
                    .ok_or_else(|| ConversionError::ObjectKindNotString {
                        kind: object_kind.clone(),
                    })?;
                let object_version = object
                    .get("apiVersion")
                    .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                    })?;
                let object_version = object_version
                    .as_str()
                    .ok_or_else(|| ConversionError::ObjectApiVersionNotString {
                        api_version: object_version.clone(),
                    })?;
                if object_kind != stringify!(Bar) {
                    return Err(ConversionError::WrongObjectKind {
                        expected_kind: stringify!(Bar).to_string(),
                        send_kind: object_kind.to_string(),
                    });
                }
                let current_object_version = Self::from_api_version(object_version)
                    .map_err(|err| ConversionError::ParseCurrentResourceVersion {
                        source: err,
                        version: object_version.to_string(),
                    })?;
                match (&current_object_version, &desired_object_version) {
                    (Self::V1Alpha1, Self::V1Alpha1) => {
                        let resource_spec: v1alpha1::BarSpec = serde_json::from_value(
                                object_spec.clone(),
                            )
                            .map_err(|err| ConversionError::DeserializeObjectSpec {
                                source: err,
                                kind: stringify!(Bar).to_string(),
                            })?;
                        tracing::trace!(
                            from = stringify!(v1alpha1), to = stringify!("v1alpha1"),
                            conversion.steps = 0usize,
                            "Successfully converted {type} object", type =
                            stringify!(Bar),
                        );
                        let mut object = object.clone();
                        *object
                            .get_mut("spec")
                            .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                            })? = serde_json::to_value(resource_spec)
                            .map_err(|err| ConversionError::SerializeObjectSpec {
                                source: err,
                                kind: stringify!(Bar).to_string(),
                            })?;
                        *object
                            .get_mut("apiVersion")
                            .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                            })? = serde_json::Value::String(
                            request.desired_api_version.clone(),
                        );
                        converted.push(object);
                    }
                    (Self::V1Alpha1, Self::V1) => {
                        let resource_spec: v1alpha1::BarSpec = serde_json::from_value(
                                object_spec.clone(),
                            )
                            .map_err(|err| ConversionError::DeserializeObjectSpec {
                                source: err,
                                kind: stringify!(Bar).to_string(),
                            })?;
                        let resource_spec: v1::BarSpec = resource_spec.into();
                        tracing::trace!(
                            from = stringify!(v1alpha1), to = stringify!("v1"),
                            conversion.steps = 1usize,
                            "Successfully converted {type} object", type =
                            stringify!(Bar),
                        );
                        let mut object = object.clone();
                        *object
                            .get_mut("spec")
                            .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                            })? = serde_json::to_value(resource_spec)
                            .map_err(|err| ConversionError::SerializeObjectSpec {
                                source: err,
                                kind: stringify!(Bar).to_string(),
                            })?;
                        *object
                            .get_mut("apiVersion")
                            .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                            })? = serde_json::Value::String(
                            request.desired_api_version.clone(),
                        );
                        converted.push(object);
                    }
                    (Self::V1Alpha1, Self::V2Alpha1) => {
                        let resource_spec: v1alpha1::BarSpec = serde_json::from_value(
                                object_spec.clone(),
                            )
                            .map_err(|err| ConversionError::DeserializeObjectSpec {
                                source: err,
                                kind: stringify!(Bar).to_string(),
                            })?;
                        let resource_spec: v1::BarSpec = resource_spec.into();
                        let resource_spec: v2alpha1::BarSpec = resource_spec.into();
                        tracing::trace!(
                            from = stringify!(v1alpha1), to = stringify!("v2alpha1"),
                            conversion.steps = 2usize,
                            "Successfully converted {type} object", type =
                            stringify!(Bar),
                        );
                        let mut object = object.clone();
                        *object
                            .get_mut("spec")
                            .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                            })? = serde_json::to_value(resource_spec)
                            .map_err(|err| ConversionError::SerializeObjectSpec {
                                source: err,
                                kind: stringify!(Bar).to_string(),
                            })?;
                        *object
                            .get_mut("apiVersion")
                            .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                            })? = serde_json::Value::String(
                            request.desired_api_version.clone(),
                        );
                        converted.push(object);
                    }
                    (Self::V1, Self::V1Alpha1) => {
                        let resource_spec: v1::BarSpec = serde_json::from_value(
                                object_spec.clone(),
                            )
                            .map_err(|err| ConversionError::DeserializeObjectSpec {
                                source: err,
                                kind: stringify!(Bar).to_string(),
                            })?;
                        let resource_spec: v1alpha1::BarSpec = resource_spec.into();
                        tracing::trace!(
                            from = stringify!(v1), to = stringify!("v1alpha1"),
                            conversion.steps = 1usize,
                            "Successfully converted {type} object", type =
                            stringify!(Bar),
                        );
                        let mut object = object.clone();
                        *object
                            .get_mut("spec")
                            .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                            })? = serde_json::to_value(resource_spec)
                            .map_err(|err| ConversionError::SerializeObjectSpec {
                                source: err,
                                kind: stringify!(Bar).to_string(),
                            })?;
                        *object
                            .get_mut("apiVersion")
                            .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                            })? = serde_json::Value::String(
                            request.desired_api_version.clone(),
                        );
                        converted.push(object);
                    }
                    (Self::V1, Self::V1) => {
                        let resource_spec: v1::BarSpec = serde_json::from_value(
                                object_spec.clone(),
                            )
                            .map_err(|err| ConversionError::DeserializeObjectSpec {
                                source: err,
                                kind: stringify!(Bar).to_string(),
                            })?;
                        tracing::trace!(
                            from = stringify!(v1), to = stringify!("v1"), conversion
                            .steps = 0usize, "Successfully converted {type} object", type
                            = stringify!(Bar),
                        );
                        let mut object = object.clone();
                        *object
                            .get_mut("spec")
                            .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                            })? = serde_json::to_value(resource_spec)
                            .map_err(|err| ConversionError::SerializeObjectSpec {
                                source: err,
                                kind: stringify!(Bar).to_string(),
                            })?;
                        *object
                            .get_mut("apiVersion")
                            .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                            })? = serde_json::Value::String(
                            request.desired_api_version.clone(),
                        );
                        converted.push(object);
                    }
                    (Self::V1, Self::V2Alpha1) => {
                        let resource_spec: v1::BarSpec = serde_json::from_value(
                                object_spec.clone(),
                            )
                            .map_err(|err| ConversionError::DeserializeObjectSpec {
                                source: err,
                                kind: stringify!(Bar).to_string(),
                            })?;
                        let resource_spec: v2alpha1::BarSpec = resource_spec.into();
                        tracing::trace!(
                            from = stringify!(v1), to = stringify!("v2alpha1"),
                            conversion.steps = 1usize,
                            "Successfully converted {type} object", type =
                            stringify!(Bar),
                        );
                        let mut object = object.clone();
                        *object
                            .get_mut("spec")
                            .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                            })? = serde_json::to_value(resource_spec)
                            .map_err(|err| ConversionError::SerializeObjectSpec {
                                source: err,
                                kind: stringify!(Bar).to_string(),
                            })?;
                        *object
                            .get_mut("apiVersion")
                            .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                            })? = serde_json::Value::String(
                            request.desired_api_version.clone(),
                        );
                        converted.push(object);
                    }
                    (Self::V2Alpha1, Self::V1Alpha1) => {
                        let resource_spec: v2alpha1::BarSpec = serde_json::from_value(
                                object_spec.clone(),
                            )
                            .map_err(|err| ConversionError::DeserializeObjectSpec {
                                source: err,
                                kind: stringify!(Bar).to_string(),
                            })?;
                        let resource_spec: v1::BarSpec = resource_spec.into();
                        let resource_spec: v1alpha1::BarSpec = resource_spec.into();
                        tracing::trace!(
                            from = stringify!(v2alpha1), to = stringify!("v1alpha1"),
                            conversion.steps = 2usize,
                            "Successfully converted {type} object", type =
                            stringify!(Bar),
                        );
                        let mut object = object.clone();
                        *object
                            .get_mut("spec")
                            .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                            })? = serde_json::to_value(resource_spec)
                            .map_err(|err| ConversionError::SerializeObjectSpec {
                                source: err,
                                kind: stringify!(Bar).to_string(),
                            })?;
                        *object
                            .get_mut("apiVersion")
                            .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                            })? = serde_json::Value::String(
                            request.desired_api_version.clone(),
                        );
                        converted.push(object);
                    }
                    (Self::V2Alpha1, Self::V1) => {
                        let resource_spec: v2alpha1::BarSpec = serde_json::from_value(
                                object_spec.clone(),
                            )
                            .map_err(|err| ConversionError::DeserializeObjectSpec {
                                source: err,
                                kind: stringify!(Bar).to_string(),
                            })?;
                        let resource_spec: v1::BarSpec = resource_spec.into();
                        tracing::trace!(
                            from = stringify!(v2alpha1), to = stringify!("v1"),
                            conversion.steps = 1usize,
                            "Successfully converted {type} object", type =
                            stringify!(Bar),
                        );
                        let mut object = object.clone();
                        *object
                            .get_mut("spec")
                            .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                            })? = serde_json::to_value(resource_spec)
                            .map_err(|err| ConversionError::SerializeObjectSpec {
                                source: err,
                                kind: stringify!(Bar).to_string(),
                            })?;
                        *object
                            .get_mut("apiVersion")
                            .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                            })? = serde_json::Value::String(
                            request.desired_api_version.clone(),
                        );
                        converted.push(object);
                    }
                    (Self::V2Alpha1, Self::V2Alpha1) => {
                        let resource_spec: v2alpha1::BarSpec = serde_json::from_value(
                                object_spec.clone(),
                            )
                            .map_err(|err| ConversionError::DeserializeObjectSpec {
                                source: err,
                                kind: stringify!(Bar).to_string(),
                            })?;
                        tracing::trace!(
                            from = stringify!(v2alpha1), to = stringify!("v2alpha1"),
                            conversion.steps = 0usize,
                            "Successfully converted {type} object", type =
                            stringify!(Bar),
                        );
                        let mut object = object.clone();
                        *object
                            .get_mut("spec")
                            .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                            })? = serde_json::to_value(resource_spec)
                            .map_err(|err| ConversionError::SerializeObjectSpec {
                                source: err,
                                kind: stringify!(Bar).to_string(),
                            })?;
                        *object
                            .get_mut("apiVersion")
                            .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                            })? = serde_json::Value::String(
                            request.desired_api_version.clone(),
                        );
                        converted.push(object);
                    }
                }
            }
            Ok(converted)
        }
    }
}
