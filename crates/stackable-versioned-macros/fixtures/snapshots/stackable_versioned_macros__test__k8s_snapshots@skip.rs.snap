---
source: crates/stackable-versioned-macros/src/lib.rs
expression: formatted
input_file: crates/stackable-versioned-macros/fixtures/inputs/k8s/skip.rs
---
#[automatically_derived]
pub mod v1alpha1 {
    use super::*;
    #[derive(
        Clone,
        Debug,
        serde::Deserialize,
        serde::Serialize,
        schemars::JsonSchema,
        kube::CustomResource,
    )]
    #[kube(
        group = "stackable.tech",
        version = "v1alpha1",
        kind = "Foo",
        singular = "foo",
        plural = "foos",
        namespaced
    )]
    pub struct FooSpec {
        pub baz: bool,
    }
}
#[automatically_derived]
impl ::std::convert::From<v1alpha1::FooSpec> for v1beta1::FooSpec {
    fn from(__sv_foospec: v1alpha1::FooSpec) -> Self {
        Self {
            bah: ::std::default::Default::default(),
            baz: __sv_foospec.baz.into(),
        }
    }
}
#[automatically_derived]
pub mod v1beta1 {
    use super::*;
    #[derive(
        Clone,
        Debug,
        serde::Deserialize,
        serde::Serialize,
        schemars::JsonSchema,
        kube::CustomResource,
    )]
    #[kube(
        group = "stackable.tech",
        version = "v1beta1",
        kind = "Foo",
        singular = "foo",
        plural = "foos",
        namespaced
    )]
    pub struct FooSpec {
        pub bah: u16,
        pub baz: bool,
    }
}
#[automatically_derived]
impl ::std::convert::From<v1beta1::FooSpec> for v1::FooSpec {
    fn from(__sv_foospec: v1beta1::FooSpec) -> Self {
        Self {
            bar: __sv_foospec.bah.into(),
            baz: __sv_foospec.baz.into(),
        }
    }
}
#[automatically_derived]
pub mod v1 {
    use super::*;
    #[derive(
        Clone,
        Debug,
        serde::Deserialize,
        serde::Serialize,
        schemars::JsonSchema,
        kube::CustomResource,
    )]
    #[kube(
        group = "stackable.tech",
        version = "v1",
        kind = "Foo",
        singular = "foo",
        plural = "foos",
        namespaced
    )]
    pub struct FooSpec {
        pub bar: usize,
        pub baz: bool,
    }
}
#[automatically_derived]
impl Foo {
    pub fn convert(
        review: kube::core::conversion::ConversionReview,
    ) -> kube::core::conversion::ConversionResponse {
        let request = kube::core::conversion::ConversionRequest::from_review(review)
            .unwrap();
        let desired_api_version = <Self as std::str::FromStr>::from_str(
                &request.desired_api_version,
            )
            .expect(
                &format!("invalid desired version for {} resource", stringify!(Foo)),
            );
        let mut converted: Vec<serde_json::Value> = Vec::with_capacity(
            request.objects.len(),
        );
        for object in &request.objects {
            let object_spec = object
                .get("spec")
                .expect("The passed object had no spec")
                .clone();
            let kind = object
                .get("kind")
                .expect("The objected asked to convert has no kind");
            let api_version = object
                .get("apiVersion")
                .expect("The objected asked to convert has no apiVersion")
                .as_str()
                .expect(
                    "The apiVersion of the objected asked to convert wasn't a String",
                );
            assert_eq!(kind, stringify!(Foo));
            let current_api_version = <Self as std::str::FromStr>::from_str(api_version)
                .expect(
                    &format!("invalid current version for {} resource", stringify!(Foo)),
                );
            match (&current_api_version, &desired_api_version) {}
        }
        let response = kube::core::conversion::ConversionResponse::for_request(request);
        response.success(converted)
    }
}
