---
source: crates/stackable-versioned-macros/src/lib.rs
expression: formatted
input_file: crates/stackable-versioned-macros/fixtures/inputs/k8s/skip.rs
---
#[automatically_derived]
pub mod v1alpha1 {
    use super::*;
    #[derive(
        Clone,
        Debug,
        serde::Deserialize,
        serde::Serialize,
        schemars::JsonSchema,
        kube::CustomResource,
    )]
    #[kube(
        group = "stackable.tech",
        version = "v1alpha1",
        kind = "Foo",
        singular = "foo",
        plural = "foos",
        namespaced
    )]
    pub struct FooSpec {
        pub baz: bool,
    }
}
#[automatically_derived]
impl ::std::convert::From<v1alpha1::FooSpec> for v1beta1::FooSpec {
    fn from(__sv_foospec: v1alpha1::FooSpec) -> Self {
        Self {
            bah: ::std::default::Default::default(),
            baz: __sv_foospec.baz.into(),
        }
    }
}
#[automatically_derived]
pub mod v1beta1 {
    use super::*;
    #[derive(
        Clone,
        Debug,
        serde::Deserialize,
        serde::Serialize,
        schemars::JsonSchema,
        kube::CustomResource,
    )]
    #[kube(
        group = "stackable.tech",
        version = "v1beta1",
        kind = "Foo",
        singular = "foo",
        plural = "foos",
        namespaced
    )]
    pub struct FooSpec {
        pub bah: u16,
        pub baz: bool,
    }
}
#[automatically_derived]
impl ::std::convert::From<v1beta1::FooSpec> for v1::FooSpec {
    fn from(__sv_foospec: v1beta1::FooSpec) -> Self {
        Self {
            bar: __sv_foospec.bah.into(),
            baz: __sv_foospec.baz.into(),
        }
    }
}
#[automatically_derived]
pub mod v1 {
    use super::*;
    #[derive(
        Clone,
        Debug,
        serde::Deserialize,
        serde::Serialize,
        schemars::JsonSchema,
        kube::CustomResource,
    )]
    #[kube(
        group = "stackable.tech",
        version = "v1",
        kind = "Foo",
        singular = "foo",
        plural = "foos",
        namespaced
    )]
    pub struct FooSpec {
        pub bar: usize,
        pub baz: bool,
    }
}
#[automatically_derived]
impl Foo {
    #[tracing::instrument(
        skip_all,
        fields(
            conversion.kind = review.types.kind,
            conversion.api_version = review.types.api_version,
        )
    )]
    pub fn convert(
        review: kube::core::conversion::ConversionReview,
    ) -> kube::core::conversion::ConversionReview {
        use kube::core::conversion::{ConversionRequest, ConversionResponse};
        use kube::core::response::StatusSummary;
        use stackable_versioned::ConversionError;
        let request = match ConversionRequest::from_review(review) {
            Ok(request) => request,
            Err(err) => {
                tracing::warn!(
                    ? err,
                    "Invalid ConversionReview send by Kubernetes apiserver. It probably did not include a request"
                );
                return ConversionResponse::invalid(kube::client::Status {
                        status: Some(StatusSummary::Failure),
                        code: 400,
                        message: format!(
                            "The ConversionReview send did not include any request: {err}"
                        ),
                        reason: "ConversionReview request missing".to_string(),
                        details: None,
                    })
                    .into_review();
            }
        };
        let converted = Self::try_convert(&request);
        let conversion_response = ConversionResponse::for_request(request);
        match converted {
            Ok(converted) => {
                tracing::debug!(
                    "Successfully converted {num} objects of type {type}", num =
                    converted.len(), type = stringify!(Foo),
                );
                conversion_response.success(converted).into_review()
            }
            Err(err) => {
                tracing::debug!(
                    "Failed to converted objects of type {type}", type = stringify!(Foo),
                );
                let error_message = err.as_human_readable_error_message();
                conversion_response
                    .failure(kube::client::Status {
                        status: Some(StatusSummary::Failure),
                        code: err.http_return_code(),
                        message: error_message.clone(),
                        reason: error_message,
                        details: None,
                    })
                    .into_review()
            }
        }
    }
    #[tracing::instrument(skip_all, err)]
    fn try_convert(
        request: &kube::core::conversion::ConversionRequest,
    ) -> Result<Vec<serde_json::Value>, stackable_versioned::ConversionError> {
        use stackable_versioned::ConversionError;
        let desired_object_version = <Self as std::str::FromStr>::from_str(
                &request.desired_api_version,
            )
            .map_err(|err| ConversionError::ParseDesiredResourceVersion {
                source: err,
                version: request.desired_api_version.to_string(),
            })?;
        let mut converted: Vec<serde_json::Value> = Vec::with_capacity(
            request.objects.len(),
        );
        for object in &request.objects {
            let object_spec = object
                .get("spec")
                .ok_or_else(|| ConversionError::ObjectHasNoSpec {
                })?;
            let object_kind = object
                .get("kind")
                .ok_or_else(|| ConversionError::ObjectHasNoKind {
                })?;
            let object_kind = object_kind
                .as_str()
                .ok_or_else(|| ConversionError::ObjectKindNotString {
                    kind: object_kind.clone(),
                })?;
            let object_version = object
                .get("apiVersion")
                .ok_or_else(|| ConversionError::ObjectHasNoApiVersion {
                })?;
            let object_version = object_version
                .as_str()
                .ok_or_else(|| ConversionError::ObjectApiVersionNotString {
                    api_version: object_version.clone(),
                })?;
            if object_kind != stringify!(Foo) {
                return Err(ConversionError::WrongObjectKind {
                    expected_kind: stringify!(Foo).to_string(),
                    send_kind: object_kind.to_string(),
                });
            }
            let current_object_version = <Self as std::str::FromStr>::from_str(
                    object_version,
                )
                .map_err(|err| ConversionError::ParseCurrentResourceVersion {
                    source: err,
                    version: object_version.to_string(),
                })?;
            match (&current_object_version, &desired_object_version) {}
        }
        Ok(converted)
    }
}
