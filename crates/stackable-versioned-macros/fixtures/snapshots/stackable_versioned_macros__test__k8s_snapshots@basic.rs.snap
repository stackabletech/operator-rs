---
source: crates/stackable-versioned-macros/src/lib.rs
expression: formatted
input_file: crates/stackable-versioned-macros/fixtures/inputs/k8s/basic.rs
---
#[automatically_derived]
pub(crate) mod v1alpha1 {
    use super::*;
    #[derive(
        Clone,
        Debug,
        serde::Deserialize,
        serde::Serialize,
        schemars::JsonSchema,
        kube::CustomResource,
    )]
    #[kube(
        group = "stackable.tech",
        version = "v1alpha1",
        kind = "Foo",
        singular = "foo",
        plural = "foos",
        namespaced
    )]
    pub struct FooSpec {
        pub baz: bool,
    }
}
#[automatically_derived]
impl ::std::convert::From<v1alpha1::FooSpec> for v1beta1::FooSpec {
    fn from(__sv_foospec: v1alpha1::FooSpec) -> Self {
        Self {
            bah: ::std::default::Default::default(),
            baz: __sv_foospec.baz.into(),
        }
    }
}
#[automatically_derived]
pub(crate) mod v1beta1 {
    use super::*;
    #[derive(
        Clone,
        Debug,
        serde::Deserialize,
        serde::Serialize,
        schemars::JsonSchema,
        kube::CustomResource,
    )]
    #[kube(
        group = "stackable.tech",
        version = "v1beta1",
        kind = "Foo",
        singular = "foo",
        plural = "foos",
        namespaced
    )]
    pub struct FooSpec {
        pub bah: u16,
        pub baz: bool,
    }
}
#[automatically_derived]
impl ::std::convert::From<v1beta1::FooSpec> for v1::FooSpec {
    fn from(__sv_foospec: v1beta1::FooSpec) -> Self {
        Self {
            bar: __sv_foospec.bah.into(),
            baz: __sv_foospec.baz.into(),
        }
    }
}
#[automatically_derived]
pub(crate) mod v1 {
    use super::*;
    #[derive(
        Clone,
        Debug,
        serde::Deserialize,
        serde::Serialize,
        schemars::JsonSchema,
        kube::CustomResource,
    )]
    #[kube(
        group = "stackable.tech",
        version = "v1",
        kind = "Foo",
        singular = "foo",
        plural = "foos",
        namespaced
    )]
    pub struct FooSpec {
        pub bar: usize,
        pub baz: bool,
    }
}
#[automatically_derived]
pub(crate) enum Foo {
    V1Alpha1,
    V1Beta1,
    V1,
}
#[automatically_derived]
impl ::std::fmt::Display for Foo {
    fn fmt(
        &self,
        f: &mut ::std::fmt::Formatter<'_>,
    ) -> ::std::result::Result<(), ::std::fmt::Error> {
        match self {
            Self::V1Alpha1 => f.write_str("v1alpha1"),
            Self::V1Beta1 => f.write_str("v1beta1"),
            Self::V1 => f.write_str("v1"),
        }
    }
}
#[automatically_derived]
impl ::std::str::FromStr for Foo {
    type Err = stackable_versioned::UnknownResourceVersionError;
    fn from_str(version: &str) -> Result<Self, Self::Err> {
        match version {
            "v1alpha1" => Ok(Self::V1Alpha1),
            "v1beta1" => Ok(Self::V1Beta1),
            "v1" => Ok(Self::V1),
            _ => {
                Err(stackable_versioned::UnknownResourceVersionError {
                    version: version.to_string(),
                })
            }
        }
    }
}
#[automatically_derived]
impl Foo {
    /// Generates a merged CRD containing all versions and marking `stored_apiversion` as stored.
    pub fn merged_crd(
        stored_apiversion: Self,
    ) -> ::std::result::Result<
        ::k8s_openapi::apiextensions_apiserver::pkg::apis::apiextensions::v1::CustomResourceDefinition,
        ::kube::core::crd::MergeError,
    > {
        ::kube::core::crd::merge_crds(
            vec![
                < v1alpha1::Foo as ::kube::core::CustomResourceExt > ::crd(), <
                v1beta1::Foo as ::kube::core::CustomResourceExt > ::crd(), < v1::Foo as
                ::kube::core::CustomResourceExt > ::crd()
            ],
            &stored_apiversion.to_string(),
        )
    }
}
#[automatically_derived]
impl Foo {
    pub fn convert(
        review: kube::core::conversion::ConversionReview,
    ) -> kube::core::conversion::ConversionResponse {
        let request = kube::core::conversion::ConversionRequest::from_review(review)
            .unwrap();
        let desired_api_version = <Self as std::str::FromStr>::from_str(
                &request.desired_api_version,
            )
            .expect(
                &format!("invalid desired version for {} resource", stringify!(Foo)),
            );
        let mut converted: Vec<serde_json::Value> = Vec::with_capacity(
            request.objects.len(),
        );
        for object in &request.objects {
            let object_spec = object
                .get("spec")
                .expect("The passed object had no spec")
                .clone();
            let kind = object
                .get("kind")
                .expect("The objected asked to convert has no kind");
            let api_version = object
                .get("apiVersion")
                .expect("The objected asked to convert has no apiVersion")
                .as_str()
                .expect(
                    "The apiVersion of the objected asked to convert wasn't a String",
                );
            assert_eq!(kind, stringify!(Foo));
            let current_api_version = <Self as std::str::FromStr>::from_str(api_version)
                .expect(
                    &format!("invalid current version for {} resource", stringify!(Foo)),
                );
            match (&current_api_version, &desired_api_version) {
                (Self::V1Alpha1, Self::V1Alpha1) => {
                    let resource: v1alpha1::FooSpec = serde_json::from_value(object_spec)
                        .expect(&format!("Failed to deserialize {}", stringify!(Foo)));
                    converted
                        .push(
                            serde_json::to_value(resource)
                                .expect(&format!("Failed to serialize {}", stringify!(Foo))),
                        );
                }
                (Self::V1Alpha1, Self::V1Beta1) => {
                    let resource: v1alpha1::FooSpec = serde_json::from_value(object_spec)
                        .expect(&format!("Failed to deserialize {}", stringify!(Foo)));
                    let resource: v1beta1::FooSpec = resource.into();
                    converted
                        .push(
                            serde_json::to_value(resource)
                                .expect(&format!("Failed to serialize {}", stringify!(Foo))),
                        );
                }
                (Self::V1Alpha1, Self::V1) => {
                    let resource: v1alpha1::FooSpec = serde_json::from_value(object_spec)
                        .expect(&format!("Failed to deserialize {}", stringify!(Foo)));
                    let resource: v1beta1::FooSpec = resource.into();
                    let resource: v1::FooSpec = resource.into();
                    converted
                        .push(
                            serde_json::to_value(resource)
                                .expect(&format!("Failed to serialize {}", stringify!(Foo))),
                        );
                }
                (Self::V1Beta1, Self::V1Alpha1) => {
                    let resource: v1beta1::FooSpec = serde_json::from_value(object_spec)
                        .expect(&format!("Failed to deserialize {}", stringify!(Foo)));
                    let resource: v1alpha1::FooSpec = resource.into();
                    converted
                        .push(
                            serde_json::to_value(resource)
                                .expect(&format!("Failed to serialize {}", stringify!(Foo))),
                        );
                }
                (Self::V1Beta1, Self::V1Beta1) => {
                    let resource: v1beta1::FooSpec = serde_json::from_value(object_spec)
                        .expect(&format!("Failed to deserialize {}", stringify!(Foo)));
                    converted
                        .push(
                            serde_json::to_value(resource)
                                .expect(&format!("Failed to serialize {}", stringify!(Foo))),
                        );
                }
                (Self::V1Beta1, Self::V1) => {
                    let resource: v1beta1::FooSpec = serde_json::from_value(object_spec)
                        .expect(&format!("Failed to deserialize {}", stringify!(Foo)));
                    let resource: v1::FooSpec = resource.into();
                    converted
                        .push(
                            serde_json::to_value(resource)
                                .expect(&format!("Failed to serialize {}", stringify!(Foo))),
                        );
                }
                (Self::V1, Self::V1Alpha1) => {
                    let resource: v1::FooSpec = serde_json::from_value(object_spec)
                        .expect(&format!("Failed to deserialize {}", stringify!(Foo)));
                    let resource: v1beta1::FooSpec = resource.into();
                    let resource: v1alpha1::FooSpec = resource.into();
                    converted
                        .push(
                            serde_json::to_value(resource)
                                .expect(&format!("Failed to serialize {}", stringify!(Foo))),
                        );
                }
                (Self::V1, Self::V1Beta1) => {
                    let resource: v1::FooSpec = serde_json::from_value(object_spec)
                        .expect(&format!("Failed to deserialize {}", stringify!(Foo)));
                    let resource: v1beta1::FooSpec = resource.into();
                    converted
                        .push(
                            serde_json::to_value(resource)
                                .expect(&format!("Failed to serialize {}", stringify!(Foo))),
                        );
                }
                (Self::V1, Self::V1) => {
                    let resource: v1::FooSpec = serde_json::from_value(object_spec)
                        .expect(&format!("Failed to deserialize {}", stringify!(Foo)));
                    converted
                        .push(
                            serde_json::to_value(resource)
                                .expect(&format!("Failed to serialize {}", stringify!(Foo))),
                        );
                }
            }
        }
        let response = kube::core::conversion::ConversionResponse::for_request(request);
        response.success(converted)
    }
}
