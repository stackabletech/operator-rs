use darling::{util::Flag, FromMeta};
use syn::Path;

/// This struct contains supported Kubernetes arguments.
///
/// The arguments are passed through to the `#[kube]` attribute. More details can be found in the
/// official docs: <https://docs.rs/kube/latest/kube/derive.CustomResource.html>.
///
/// Supported arguments are:
///
/// - `group`, which sets the CRD group, usually the domain of the company.
/// - `kind`, which allows overwriting the kind field of the CRD. This defaults to the struct name
///    (without the 'Spec' suffix).
/// - `singular`, to specify the singular name of the CR object.
/// - `plural`, to specify the plural name of the CR object.
/// - `namespaced`, to specify that this is a namespaced resource rather than cluster level.
/// - `crates`: Override specific crates.
/// - `status`: Sets the specified struct as the status subresource.
/// - `shortname`: Sets the shortname of the CRD.
/// - `skip`, which controls skipping parts of the generation.
#[derive(Clone, Debug, FromMeta)]
pub(crate) struct KubernetesArguments {
    pub(crate) group: String,
    pub(crate) kind: Option<String>,
    pub(crate) singular: Option<String>,
    pub(crate) plural: Option<String>,
    pub(crate) namespaced: Flag,
    // root
    pub(crate) crates: Option<KubernetesCrateArguments>,
    pub(crate) status: Option<String>,
    // derive
    // schema
    // scale
    // printcolumn
    #[darling(multiple, rename = "shortname")]
    pub(crate) shortnames: Vec<String>,
    // category
    // selectable
    // doc
    // annotation
    // label
    pub(crate) skip: Option<KubernetesSkipArguments>,
}

// #[derive(Debug, Default, Clone)]
// pub struct FromMetaVec<T>(Vec<T>);

// impl<T> Deref for FromMetaVec<T> {
//     type Target = Vec<T>;

//     fn deref(&self) -> &Self::Target {
//         &self.0
//     }
// }

// impl<T> FromMeta for FromMetaVec<T> {
//     fn from_nested_meta(item: &darling::ast::NestedMeta) -> darling::Result<Self> {
//         (match *item {
//             darling::ast::NestedMeta::Lit(ref lit) => Self::from_value(lit),
//             darling::ast::NestedMeta::Meta(ref mi) => Self::from_meta(mi),
//         })
//         .map_err(|e| e.with_span(item))
//     }

//     fn from_meta(item: &syn::Meta) -> darling::Result<Self> {
//         (match *item {
//             syn::Meta::Path(_) => Self::from_word(),
//             syn::Meta::List(ref value) => Self::from_list(
//                 &darling::ast::NestedMeta::parse_meta_list(value.tokens.clone())?[..],
//             ),
//             syn::Meta::NameValue(ref value) => Self::from_expr(&value.value),
//         })
//         .map_err(|e| e.with_span(item))
//     }

//     fn from_none() -> Option<Self> {
//         None
//     }

//     fn from_word() -> darling::Result<Self> {
//         Err(darling::Error::unsupported_format("word"))
//     }

//     fn from_list(items: &[darling::ast::NestedMeta]) -> darling::Result<Self> {
//         Err(darling::Error::unsupported_format("list"))
//     }

//     fn from_value(value: &syn::Lit) -> darling::Result<Self> {
//         (match *value {
//             syn::Lit::Bool(ref b) => Self::from_bool(b.value),
//             syn::Lit::Str(ref s) => Self::from_string(&s.value()),
//             syn::Lit::Char(ref ch) => Self::from_char(ch.value()),
//             _ => Err(darling::Error::unexpected_lit_type(value)),
//         })
//         .map_err(|e| e.with_span(value))
//     }

//     fn from_expr(expr: &syn::Expr) -> darling::Result<Self> {
//         match *expr {
//             syn::Expr::Lit(ref lit) => Self::from_value(&lit.lit),
//             syn::Expr::Group(ref group) => {
//                 // syn may generate this invisible group delimiter when the input to the darling
//                 // proc macro (specifically, the attributes) are generated by a
//                 // macro_rules! (e.g. propagating a macro_rules!'s expr)
//                 // Since we want to basically ignore these invisible group delimiters,
//                 // we just propagate the call to the inner expression.
//                 Self::from_expr(&group.expr)
//             }
//             _ => Err(darling::Error::unexpected_expr_type(expr)),
//         }
//         .map_err(|e| e.with_span(expr))
//     }

//     fn from_char(value: char) -> darling::Result<Self> {
//         Err(darling::Error::unexpected_type("char"))
//     }

//     fn from_string(value: &str) -> darling::Result<Self> {
//         Err(darling::Error::unexpected_type("string"))
//     }

//     fn from_bool(value: bool) -> darling::Result<Self> {
//         Err(darling::Error::unexpected_type("bool"))
//     }
// }

/// This struct contains supported kubernetes skip arguments.
///
/// Supported arguments are:
///
/// - `merged_crd` flag, which skips generating the `crd()` and `merged_crd()` functions are
///    generated.
#[derive(Clone, Debug, FromMeta)]
pub(crate) struct KubernetesSkipArguments {
    /// Whether the `crd()` and `merged_crd()` generation should be skipped for
    /// this container.
    pub(crate) merged_crd: Flag,
}

/// This struct contains crate overrides to be passed to `#[kube]`.
#[derive(Clone, Debug, FromMeta)]
pub(crate) struct KubernetesCrateArguments {
    pub(crate) kube_core: Option<Path>,
    pub(crate) k8s_openapi: Option<Path>,
    pub(crate) schemars: Option<Path>,
    pub(crate) serde: Option<Path>,
    pub(crate) serde_json: Option<Path>,
}
